# ATACï¼ˆAny To Any Connectivityï¼‰- Discord Bot ã‚³ã‚¢ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

## ç›®æ¬¡

1. [ã‚·ã‚¹ãƒ†ãƒ æ¦‚è¦](#ã‚·ã‚¹ãƒ†ãƒ æ¦‚è¦)
2. [ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å…¨ä½“å›³](#ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å…¨ä½“å›³)
3. [ã‚³ã‚¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ§‹æˆ](#ã‚³ã‚¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ§‹æˆ)
4. [çµ±åˆã®å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³](#çµ±åˆã®å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³)
5. [ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯](#ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯)
6. [ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ](#ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ)
7. [å®Ÿè£…ä¾‹](#å®Ÿè£…ä¾‹)

---

## ã‚·ã‚¹ãƒ†ãƒ æ¦‚è¦

ATAC ã¯ Discord Bot ã‚’ä»‹ã—ã¦ã€è¤‡æ•°ã®å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã‚’çµ±åˆã—ã€é¡§å®¢ã”ã¨ã«ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã•ã‚ŒãŸæ©Ÿèƒ½ã‚’æä¾›ã™ã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã™ã€‚

**ä¸»ãªç‰¹å¾´ï¼š**
- **ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å‹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**ï¼šæ©Ÿèƒ½ã‚’ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¨ã—ã¦ç‹¬ç«‹ã•ã›ã€é¡§å®¢ã«åˆã‚ã›ã¦çµ„ã¿åˆã‚ã›å¯èƒ½
- **ãƒãƒ«ãƒãƒ†ãƒŠãƒ³ãƒˆå¯¾å¿œ**ï¼šè¤‡æ•°ã®é¡§å®¢ã«ç•°ãªã‚‹æ©Ÿèƒ½ã‚»ãƒƒãƒˆã‚’æä¾›
- **ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•å‹**ï¼šè¤‡æ•°ã®ãƒˆãƒªã‚¬ãƒ¼æ–¹å¼ï¼ˆã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ã€ãƒªãƒ—ãƒ©ã‚¤ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸åå¿œã€cronã€webhookï¼‰ã«å¯¾å¿œ
- **çµ±åˆã‚µãƒ¼ãƒ“ã‚¹ç®¡ç†**ï¼šLLMã€RAGã€Pineconeã€Redisã€Firebase ãªã©è¤‡æ•°ã‚µãƒ¼ãƒ“ã‚¹ã‚’çµ±ä¸€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ç®¡ç†

---

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å…¨ä½“å›³

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Discord Bot (discord.js)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚          Event Ingestion Layer                        â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ â€¢ Slash Command Handler  â€¢ Message Reply Listener    â”‚  â”‚
â”‚  â”‚ â€¢ Message Mention Handler â€¢ Cron Job Processor      â”‚  â”‚
â”‚  â”‚ â€¢ Webhook Event Router                              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                           â†“                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚       Core Orchestration & Routing Engine            â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ â€¢ Customer Registry â€¢ Feature Router â€¢ Pipeline Mgr   â”‚  â”‚
â”‚  â”‚ â€¢ Context Manager â€¢ Error Handler â€¢ Rate Limiter      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                           â†“                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         Plugin System (Feature Plugins)              â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ Plugin 1        Plugin 2        Plugin 3              â”‚  â”‚
â”‚  â”‚ (Chat/RAG)      (Attendance)    (Calendar)            â”‚  â”‚
â”‚  â”‚                                                        â”‚  â”‚
â”‚  â”‚ â€¢ Initialize    â€¢ Initialize    â€¢ Initialize          â”‚  â”‚
â”‚  â”‚ â€¢ Execute       â€¢ Execute       â€¢ Execute             â”‚  â”‚
â”‚  â”‚ â€¢ Cleanup       â€¢ Cleanup       â€¢ Cleanup             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                           â†“                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚    Integration Service Layer (Adapters)              â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ LLM Adapter  Pinecone Adapter  Redis Adapter          â”‚  â”‚
â”‚  â”‚ Firebase Auth  Firestore  Storage  Google Calendar    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                           â†“                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚          â”‚          â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Vercel AI â”‚  â”‚Pineconeâ”‚  â”‚ Upstash  â”‚
        â”‚   SDK     â”‚  â”‚Vector  â”‚  â”‚ Redis    â”‚
        â”‚           â”‚  â”‚DB      â”‚  â”‚          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Firebase  â”‚  â”‚Firebaseâ”‚  â”‚  Google  â”‚
        â”‚  Auth     â”‚  â”‚Firestore  Calendar  â”‚
        â”‚           â”‚  â”‚        â”‚  â”‚          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ã‚³ã‚¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ§‹æˆ

### 1. ã‚¤ãƒ™ãƒ³ãƒˆå…¥åŠ›ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆEvent Ingestionï¼‰

```typescript
// src/events/EventManager.ts

interface EventContext {
  customerId: string;
  guildId: string;
  userId: string;
  channelId: string;
  type: 'slash' | 'mention' | 'reply' | 'cron' | 'webhook';
  payload: Record<string, any>;
  timestamp: Date;
}

interface EventHandler {
  name: string;
  type: 'slash' | 'mention' | 'reply' | 'cron' | 'webhook';
  register(client: Discord.Client): void;
  handle(context: EventContext): Promise<void>;
}
```

**å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼š**

- **Slash Command**: Discord ã®æ¨™æº–ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ API
- **Message Reply**: `message.reply()` ã‚¤ãƒ™ãƒ³ãƒˆæ¤œçŸ¥
- **Mention Handler**: ãƒœãƒƒãƒˆåãƒ¡ãƒ³ã‚·ãƒ§ãƒ³æ¤œçŸ¥ï¼ˆã‚ªãƒ¼ãƒˆãƒ¬ã‚¹ãƒãƒ³ã‚¹ï¼‰
- **Cron Job**: node-cron ã¾ãŸã¯ AWS Lambda ã§ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«å®Ÿè¡Œ
- **Webhook**: HTTP webhook ãƒˆãƒªã‚¬ãƒ¼ï¼ˆå¤–éƒ¨ã‚¤ãƒ™ãƒ³ãƒˆé€£æºï¼‰

### 2. ã‚³ã‚¢ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å±¤

```typescript
// src/core/ATACOrchestrator.ts

interface CustomerConfig {
  customerId: string;
  name: string;
  features: string[]; // æœ‰åŠ¹ãªãƒ—ãƒ©ã‚°ã‚¤ãƒ³ ID
  eventMappings: EventMapping[];
  settings: Record<string, any>;
}

interface EventMapping {
  eventType: string; // 'slash' | 'mention' | ...
  featureId: string;
  config: Record<string, any>;
}

class ATACOrchestrator {
  private customerRegistry: Map<string, CustomerConfig>;
  private pluginLoader: PluginLoader;
  private eventRouter: EventRouter;
  private contextManager: ContextManager;

  async routeEvent(context: EventContext): Promise<void> {
    // 1. ã‚«ã‚¹ã‚¿ãƒãƒ¼æ¤œè¨¼
    const customer = this.customerRegistry.get(context.customerId);
    if (!customer) throw new Error('Customer not found');

    // 2. ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒƒãƒ”ãƒ³ã‚°æ¤œç´¢
    const mappings = customer.eventMappings.filter(
      m => m.eventType === context.type
    );

    // 3. å„ãƒãƒƒãƒ”ãƒ³ã‚°ã«å¯¾ã—ã¦ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œ
    for (const mapping of mappings) {
      const plugin = this.pluginLoader.get(mapping.featureId);
      const enrichedContext = await this.contextManager.enrich(context, mapping);
      
      try {
        await plugin.execute(enrichedContext);
      } catch (error) {
        // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        await this.handleError(context, error);
      }
    }
  }
}
```

### 3. ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ 

```typescript
// src/plugins/BasePlugin.ts

export interface PluginConfig {
  id: string;
  name: string;
  version: string;
  requiredServices: string[]; // ä¾å­˜ã™ã‚‹ã‚µãƒ¼ãƒ“ã‚¹
}

export interface PluginContext extends EventContext {
  services: ServiceContainer;
  config: Record<string, any>;
  response: {
    message?: string;
    embeds?: Discord.Embed[];
    components?: Discord.ActionRowBuilder[];
    files?: Discord.FileOptions[];
  };
}

export abstract class BasePlugin {
  protected config: PluginConfig;

  abstract async initialize(): Promise<void>;
  abstract async execute(context: PluginContext): Promise<void>;
  abstract async cleanup(): Promise<void>;

  async validateContext(context: PluginContext): Promise<boolean> {
    // å¿…è¦ãªã‚µãƒ¼ãƒ“ã‚¹ãŒåˆ©ç”¨å¯èƒ½ã‹ç¢ºèª
    const missingServices = this.config.requiredServices.filter(
      service => !context.services.has(service)
    );
    return missingServices.length === 0;
  }
}
```

**ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¾‹ï¼š**

```typescript
// src/plugins/ChatPlugin.ts

class ChatPlugin extends BasePlugin {
  constructor(
    private llmAdapter: LLMAdapter,
    private ragAdapter: RAGAdapter
  ) {
    super();
    this.config = {
      id: 'chat',
      name: 'Chat & Conversation',
      version: '1.0.0',
      requiredServices: ['llm', 'rag'],
    };
  }

  async execute(context: PluginContext): Promise<void> {
    const userMessage = context.payload.message || '';
    
    // RAG ãŒæœ‰åŠ¹ãªå ´åˆã¯ RAG ã§å›ç­”
    if (context.config.useRAG) {
      const ragResult = await this.ragAdapter.search(userMessage);
      const response = await this.llmAdapter.generate({
        messages: [
          { role: 'user', content: userMessage },
          { role: 'system', content: `Context: ${ragResult.content}` },
        ],
      });
      context.response.message = response.text;
    } else {
      // é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆ
      const response = await this.llmAdapter.generate({
        messages: [{ role: 'user', content: userMessage }],
      });
      context.response.message = response.text;
    }
  }
}
```

### 4. çµ±åˆã‚µãƒ¼ãƒ“ã‚¹ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆAdaptersï¼‰

```typescript
// src/services/adapters/index.ts

// LLM Adapter (Vercel AI SDK)
export interface LLMAdapter {
  generate(options: LLMGenerateOptions): Promise<LLMResponse>;
  generateStream(options: LLMGenerateOptions): AsyncIterable<string>;
  generateWithTools(options: LLMWithToolsOptions): Promise<LLMToolResponse>;
}

// RAG Adapter (Pinecone + Discord Message History)
export interface RAGAdapter {
  search(query: string, options?: RAGOptions): Promise<RAGResult>;
  indexMessages(messages: Discord.Message[]): Promise<void>;
}

// Auth Adapter (Firebase Auth)
export interface AuthAdapter {
  verifyUser(userId: string): Promise<UserProfile>;
  refreshToken(token: string): Promise<string>;
}

// Data Adapter (Firestore)
export interface DataAdapter {
  get(collection: string, docId: string): Promise<any>;
  set(collection: string, docId: string, data: any): Promise<void>;
  query(collection: string, filters: QueryFilter[]): Promise<any[]>;
}

// Storage Adapter (Firebase Storage)
export interface StorageAdapter {
  upload(bucket: string, path: string, file: Buffer): Promise<string>;
  download(bucket: string, path: string): Promise<Buffer>;
}

// Cache Adapter (Upstash Redis)
export interface CacheAdapter {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T, ttl?: number): Promise<void>;
  del(key: string): Promise<void>;
}

// Calendar Adapter (Google Calendar API)
export interface CalendarAdapter {
  createEvent(event: CalendarEvent): Promise<string>;
  listEvents(options?: ListEventsOptions): Promise<CalendarEvent[]>;
}
```

**å®Ÿè£…ä¾‹ï¼ˆLLM Adapterï¼‰ï¼š**

```typescript
// src/services/adapters/LLMAdapter.ts

import { generateText, generateObject, tool } from 'ai';
import { openai } from '@ai-sdk/openai';
import { anthropic } from '@ai-sdk/anthropic';

export class LLMAdapterImpl implements LLMAdapter {
  private models: Map<string, LanguageModel>;

  constructor() {
    this.models = new Map([
      ['gpt-4', openai('gpt-4')],
      ['claude', anthropic('claude-3-sonnet-20240229')],
    ]);
  }

  async generate(options: LLMGenerateOptions): Promise<LLMResponse> {
    const model = this.models.get(options.model || 'gpt-4');
    const { text } = await generateText({
      model: model!,
      messages: options.messages,
      system: options.system,
      temperature: options.temperature || 0.7,
      maxTokens: options.maxTokens || 2000,
    });

    return { text, finishReason: 'stop' };
  }

  async generateWithTools(
    options: LLMWithToolsOptions
  ): Promise<LLMToolResponse> {
    const model = this.models.get(options.model || 'gpt-4');
    const tools = this.buildToolDefinitions(options.tools);

    const { text, toolCalls } = await generateText({
      model: model!,
      messages: options.messages,
      tools,
      maxTokens: 2000,
    });

    return { text, toolCalls: toolCalls || [] };
  }

  private buildToolDefinitions(tools: ToolDefinition[]) {
    return Object.fromEntries(
      tools.map(t => [
        t.name,
        tool({
          description: t.description,
          parameters: t.parameters,
          execute: t.execute,
        }),
      ])
    );
  }
}
```

---

## çµ±åˆã®å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³

### ãƒ‘ã‚¿ãƒ¼ãƒ³ 1ï¼šç°¡æ˜“ãƒãƒ£ãƒƒãƒˆï¼ˆLLM ã®ã¿ï¼‰

```typescript
// Customer: å°è¦æ¨¡ä¼æ¥­
// Features: ['chat']

const config: CustomerConfig = {
  customerId: 'customer-001',
  name: 'Small Business A',
  features: ['chat'],
  eventMappings: [
    {
      eventType: 'slash',
      featureId: 'chat',
      config: {
        commandName: 'chat',
        model: 'gpt-4',
      },
    },
    {
      eventType: 'mention',
      featureId: 'chat',
      config: {
        model: 'gpt-4',
        useRAG: false,
      },
    },
  ],
};
```

### ãƒ‘ã‚¿ãƒ¼ãƒ³ 2ï¼šã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚º RAGï¼ˆè¤‡åˆçµ±åˆï¼‰

```typescript
// Customer: å¤§æ‰‹ä¼æ¥­
// Features: ['chat', 'rag', 'attendance', 'calendar']

const config: CustomerConfig = {
  customerId: 'enterprise-001',
  name: 'Enterprise Corp',
  features: ['chat', 'rag', 'attendance', 'calendar'],
  eventMappings: [
    // RAG ãƒ™ãƒ¼ã‚¹ã® Q&A
    {
      eventType: 'slash',
      featureId: 'chat',
      config: {
        commandName: 'question',
        model: 'claude',
        useRAG: true,
        ragIndexes: ['company-docs', 'internal-knowledge'],
      },
    },
    // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³æ™‚ã®è‡ªå‹•å¿œç­”
    {
      eventType: 'mention',
      featureId: 'chat',
      config: {
        model: 'claude',
        useRAG: true,
      },
    },
    // å‹¤æ€ è¨˜éŒ²
    {
      eventType: 'slash',
      featureId: 'attendance',
      config: {
        checkInCommand: 'checkin',
        checkOutCommand: 'checkout',
        storage: 'firestore',
      },
    },
    // äºˆå®šè¿½åŠ 
    {
      eventType: 'slash',
      featureId: 'calendar',
      config: {
        commandName: 'schedule',
        calendarId: 'company@calendar.google.com',
      },
    },
    // å®šæœŸé€šçŸ¥ï¼ˆcronï¼‰
    {
      eventType: 'cron',
      featureId: 'reminder',
      config: {
        schedule: '0 9 * * MON-FRI', // å¹³æ—¥ 9 æ™‚
        message: 'Daily standup at 10 AM',
      },
    },
  ],
};
```

---

## ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯

### å‹•çš„ãƒ—ãƒ©ã‚°ã‚¤ãƒ³èª­ã¿è¾¼ã¿

```typescript
// src/core/PluginLoader.ts

export class PluginLoader {
  private plugins: Map<string, BasePlugin> = new Map();
  private pluginRegistry: PluginRegistry;

  async loadPlugin(pluginId: string, config?: Record<string, any>): Promise<void> {
    // 1. ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—
    const metadata = this.pluginRegistry.get(pluginId);
    if (!metadata) throw new Error(`Plugin not found: ${pluginId}`);

    // 2. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å‹•çš„èª­ã¿è¾¼ã¿
    const PluginClass = await import(metadata.path);

    // 3. ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
    const instance = new PluginClass.default(
      this.getRequiredServices(metadata.requiredServices),
      config
    );

    // 4. åˆæœŸåŒ–
    await instance.initialize();

    // 5. ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã«ç™»éŒ²
    this.plugins.set(pluginId, instance);
  }

  get(pluginId: string): BasePlugin {
    const plugin = this.plugins.get(pluginId);
    if (!plugin) throw new Error(`Plugin not loaded: ${pluginId}`);
    return plugin;
  }

  private getRequiredServices(serviceNames: string[]): ServiceContainer {
    const container = new ServiceContainer();
    for (const name of serviceNames) {
      container.set(name, this.serviceRegistry.get(name));
    }
    return container;
  }
}
```

### ã‚µãƒ¼ãƒ“ã‚¹ã‚³ãƒ³ãƒ†ãƒŠï¼ˆDI ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰

```typescript
// src/core/ServiceContainer.ts

export class ServiceContainer {
  private services: Map<string, any> = new Map();

  register<T>(name: string, factory: () => T | Promise<T>): void {
    this.services.set(name, { factory, instance: null });
  }

  async get<T>(name: string): Promise<T> {
    const entry = this.services.get(name);
    if (!entry) throw new Error(`Service not registered: ${name}`);

    if (!entry.instance) {
      entry.instance = await entry.factory();
    }
    return entry.instance;
  }

  has(name: string): boolean {
    return this.services.has(name);
  }
}
```

### åˆæœŸåŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

```typescript
// src/bootstrap.ts

export async function initializeATAC(): Promise<ATACOrchestrator> {
  // ã‚µãƒ¼ãƒ“ã‚¹ã‚³ãƒ³ãƒ†ãƒŠã®æ§‹ç¯‰
  const services = new ServiceContainer();

  // å„ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®ç™»éŒ²
  services.register('llm', () => 
    new LLMAdapterImpl(process.env.AI_GATEWAY_KEY)
  );

  services.register('rag', () => 
    new RAGAdapterImpl(
      process.env.PINECONE_API_KEY,
      process.env.PINECONE_INDEX_NAME
    )
  );

  services.register('cache', () => 
    new CacheAdapterImpl(process.env.REDIS_URL)
  );

  services.register('auth', async () => {
    const admin = await initializeApp({
      credential: applicationDefault(),
      projectId: process.env.FIREBASE_PROJECT_ID,
    });
    return new AuthAdapterImpl(admin);
  });

  services.register('firestore', async () => {
    const admin = await services.get('auth');
    return new DataAdapterImpl(getFirestore(admin.app));
  });

  services.register('storage', async () => {
    const admin = await services.get('auth');
    return new StorageAdapterImpl(getStorage(admin.app));
  });

  services.register('calendar', () => 
    new CalendarAdapterImpl(process.env.GOOGLE_CALENDAR_CREDENTIALS)
  );

  // ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿æ§‹ç¯‰
  const orchestrator = new ATACOrchestrator(services);

  // ã‚«ã‚¹ã‚¿ãƒãƒ¼è¨­å®šã‚’ãƒ­ãƒ¼ãƒ‰
  await orchestrator.loadCustomerConfigs();

  return orchestrator;
}
```

---

## ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ

```
atac-discord-bot/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ ATACOrchestrator.ts       # ãƒ¡ã‚¤ãƒ³ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿
â”‚   â”‚   â”œâ”€â”€ EventManager.ts           # ã‚¤ãƒ™ãƒ³ãƒˆç®¡ç†
â”‚   â”‚   â”œâ”€â”€ PluginLoader.ts           # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å‹•çš„èª­ã¿è¾¼ã¿
â”‚   â”‚   â”œâ”€â”€ ServiceContainer.ts       # DI ã‚³ãƒ³ãƒ†ãƒŠ
â”‚   â”‚   â”œâ”€â”€ ContextManager.ts         # ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæ‹¡å¼µ
â”‚   â”‚   â””â”€â”€ PipelineExecutor.ts       # ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³
â”‚   â”‚
â”‚   â”œâ”€â”€ events/
â”‚   â”‚   â”œâ”€â”€ SlashCommandHandler.ts
â”‚   â”‚   â”œâ”€â”€ MessageMentionHandler.ts
â”‚   â”‚   â”œâ”€â”€ ReplyHandler.ts
â”‚   â”‚   â”œâ”€â”€ CronJobHandler.ts
â”‚   â”‚   â””â”€â”€ WebhookHandler.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ plugins/
â”‚   â”‚   â”œâ”€â”€ BasePlugin.ts             # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åŸºåº•ã‚¯ãƒ©ã‚¹
â”‚   â”‚   â”œâ”€â”€ chat/
â”‚   â”‚   â”‚   â”œâ”€â”€ ChatPlugin.ts
â”‚   â”‚   â”‚   â””â”€â”€ ChatConfig.ts
â”‚   â”‚   â”œâ”€â”€ rag/
â”‚   â”‚   â”‚   â”œâ”€â”€ RAGPlugin.ts
â”‚   â”‚   â”‚   â””â”€â”€ RAGConfig.ts
â”‚   â”‚   â”œâ”€â”€ attendance/
â”‚   â”‚   â”‚   â”œâ”€â”€ AttendancePlugin.ts
â”‚   â”‚   â”‚   â””â”€â”€ AttendanceConfig.ts
â”‚   â”‚   â”œâ”€â”€ calendar/
â”‚   â”‚   â”‚   â”œâ”€â”€ CalendarPlugin.ts
â”‚   â”‚   â”‚   â””â”€â”€ CalendarConfig.ts
â”‚   â”‚   â”œâ”€â”€ transcription/
â”‚   â”‚   â”‚   â”œâ”€â”€ TranscriptionPlugin.ts
â”‚   â”‚   â”‚   â””â”€â”€ TranscriptionConfig.ts
â”‚   â”‚   â””â”€â”€ index.ts                  # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ¬ã‚¸ã‚¹ãƒˆãƒª
â”‚   â”‚
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ adapters/
â”‚   â”‚   â”‚   â”œâ”€â”€ LLMAdapter.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ RAGAdapter.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ AuthAdapter.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ DataAdapter.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ StorageAdapter.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ CacheAdapter.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ CalendarAdapter.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ interfaces/
â”‚   â”‚   â”‚   â”œâ”€â”€ ILLMAdapter.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ IRAGAdapter.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ ICacheAdapter.ts
â”‚   â”‚   â”‚   â””â”€â”€ ... (other interfaces)
â”‚   â”‚   â””â”€â”€ ServiceRegistry.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”œâ”€â”€ CustomerConfig.ts         # ã‚«ã‚¹ã‚¿ãƒãƒ¼è¨­å®šç®¡ç†
â”‚   â”‚   â”œâ”€â”€ ConfigLoader.ts           # è¨­å®šèª­ã¿è¾¼ã¿
â”‚   â”‚   â”œâ”€â”€ customers/
â”‚   â”‚   â”‚   â”œâ”€â”€ customer-001.json
â”‚   â”‚   â”‚   â”œâ”€â”€ customer-002.json
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â””â”€â”€ secrets.env
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ logger.ts
â”‚   â”‚   â”œâ”€â”€ errorHandler.ts
â”‚   â”‚   â”œâ”€â”€ rateLimiter.ts
â”‚   â”‚   â””â”€â”€ validators.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ index.ts                  # å…±é€šå‹å®šç¾©
â”‚   â”‚   â””â”€â”€ discord.ts
â”‚   â”‚
â”‚   â””â”€â”€ main.ts                       # ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ fixtures/
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ ARCHITECTURE.md
â”‚   â”œâ”€â”€ PLUGIN_DEVELOPMENT.md
â”‚   â”œâ”€â”€ API_REFERENCE.md
â”‚   â””â”€â”€ DEPLOYMENT.md
â”‚
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ .env.example
â””â”€â”€ README.md
```

---

## å®Ÿè£…ä¾‹

### ä¾‹ 1ï¼šãƒãƒ£ãƒƒãƒˆãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®å®Ÿè£…

```typescript
// src/plugins/chat/ChatPlugin.ts

import { BasePlugin, PluginContext } from '../BasePlugin';
import { LLMAdapter } from '../../services/adapters/LLMAdapter';
import { RAGAdapter } from '../../services/adapters/RAGAdapter';
import { CacheAdapter } from '../../services/adapters/CacheAdapter';

export class ChatPlugin extends BasePlugin {
  constructor(
    private llmAdapter: LLMAdapter,
    private ragAdapter: RAGAdapter,
    private cacheAdapter: CacheAdapter,
    config?: Record<string, any>
  ) {
    super();
    this.config = {
      id: 'chat',
      name: 'Chat & Conversation',
      version: '1.0.0',
      requiredServices: ['llm'],
    };
  }

  async initialize(): Promise<void> {
    console.log('[ChatPlugin] Initializing...');
    // ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å›ºæœ‰ã®åˆæœŸåŒ–å‡¦ç†
  }

  async execute(context: PluginContext): Promise<void> {
    const userMessage = context.payload.message || '';
    const useRAG = context.config.useRAG || false;

    try {
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç¢ºèª
      const cacheKey = `chat:${context.userId}:${userMessage}`;
      const cached = await this.cacheAdapter.get<string>(cacheKey);
      if (cached) {
        context.response.message = cached;
        return;
      }

      let response: string;

      if (useRAG) {
        // RAG ã‚’ä½¿ç”¨ã—ãŸå›ç­”ç”Ÿæˆ
        const searchResults = await this.ragAdapter.search(userMessage, {
          topK: 5,
        });

        const ragContext = searchResults
          .map(r => r.content)
          .join('\n---\n');

        const llmResponse = await this.llmAdapter.generate({
          messages: [
            {
              role: 'system',
              content: `You are a helpful assistant. Use the following context to answer questions:\n${ragContext}`,
            },
            {
              role: 'user',
              content: userMessage,
            },
          ],
          model: context.config.model || 'gpt-4',
          temperature: context.config.temperature || 0.7,
        });

        response = llmResponse.text;
      } else {
        // é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆ
        const llmResponse = await this.llmAdapter.generate({
          messages: [
            {
              role: 'user',
              content: userMessage,
            },
          ],
          model: context.config.model || 'gpt-4',
          temperature: context.config.temperature || 0.7,
        });

        response = llmResponse.text;
      }

      // é•·ã„å¿œç­”ã¯åˆ†å‰²
      if (response.length > 2000) {
        const chunks = response.match(/[\s\S]{1,1900}/g) || [];
        context.response.message = chunks[0];
        // ç¶šãã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã§è¿”ã™ãªã©
      } else {
        context.response.message = response;
      }

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜ï¼ˆ5 åˆ†ï¼‰
      await this.cacheAdapter.set(cacheKey, response, 300);
    } catch (error) {
      context.response.message =
        'Sorry, I encountered an error processing your request.';
      throw error;
    }
  }

  async cleanup(): Promise<void> {
    console.log('[ChatPlugin] Cleaning up...');
  }
}
```

### ä¾‹ 2ï¼šå‹¤æ€ ç®¡ç†ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®å®Ÿè£…

```typescript
// src/plugins/attendance/AttendancePlugin.ts

import { BasePlugin, PluginContext } from '../BasePlugin';
import { DataAdapter } from '../../services/adapters/DataAdapter';
import { AuthAdapter } from '../../services/adapters/AuthAdapter';

interface AttendanceRecord {
  userId: string;
  date: string;
  checkInTime?: Date;
  checkOutTime?: Date;
  duration?: number; // å‹¤å‹™æ™‚é–“ï¼ˆåˆ†ï¼‰
}

export class AttendancePlugin extends BasePlugin {
  constructor(
    private dataAdapter: DataAdapter,
    private authAdapter: AuthAdapter,
    config?: Record<string, any>
  ) {
    super();
    this.config = {
      id: 'attendance',
      name: 'Attendance Management',
      version: '1.0.0',
      requiredServices: ['firestore', 'auth'],
    };
  }

  async initialize(): Promise<void> {
    console.log('[AttendancePlugin] Initializing...');
  }

  async execute(context: PluginContext): Promise<void> {
    const command = context.payload.subcommand;
    const userId = context.userId;
    const today = new Date().toISOString().split('T')[0];

    try {
      if (command === 'checkin') {
        await this.handleCheckIn(userId, today);
        context.response.message = 'âœ… Check-in recorded!';
      } else if (command === 'checkout') {
        const duration = await this.handleCheckOut(userId, today);
        context.response.message = `âœ… Check-out recorded! (${duration} hours worked)`;
      } else if (command === 'status') {
        const status = await this.getAttendanceStatus(userId, today);
        context.response.message = this.formatStatusMessage(status);
      }
    } catch (error) {
      context.response.message = 'Failed to process attendance record.';
      throw error;
    }
  }

  private async handleCheckIn(userId: string, date: string): Promise<void> {
    const today = `${date}`;
    const record: AttendanceRecord = {
      userId,
      date: today,
      checkInTime: new Date(),
    };

    await this.dataAdapter.set('attendance', `${userId}_${today}`, record);
  }

  private async handleCheckOut(userId: string, date: string): Promise<number> {
    const record = await this.dataAdapter.get('attendance', `${userId}_${date}`);
    if (!record || !record.checkInTime) {
      throw new Error('No check-in record found');
    }

    const checkOutTime = new Date();
    const duration = Math.round(
      (checkOutTime.getTime() - new Date(record.checkInTime).getTime()) /
        (1000 * 60)
    );

    await this.dataAdapter.set('attendance', `${userId}_${date}`, {
      ...record,
      checkOutTime,
      duration: Math.round(duration / 60),
    });

    return Math.round(duration / 60);
  }

  private async getAttendanceStatus(
    userId: string,
    date: string
  ): Promise<AttendanceRecord> {
    return this.dataAdapter.get('attendance', `${userId}_${date}`);
  }

  private formatStatusMessage(status: AttendanceRecord): string {
    let message = `ğŸ“Š Attendance Status (${status.date})\n`;
    if (status.checkInTime) {
      message += `Check-in: ${new Date(status.checkInTime).toLocaleTimeString()}\n`;
    }
    if (status.checkOutTime) {
      message += `Check-out: ${new Date(status.checkOutTime).toLocaleTimeString()}\n`;
      message += `Duration: ${status.duration} hours`;
    } else {
      message += `Status: Still working...`;
    }
    return message;
  }

  async cleanup(): Promise<void> {
    console.log('[AttendancePlugin] Cleaning up...');
  }
}
```

### ä¾‹ 3ï¼šãƒ¡ã‚¤ãƒ³å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«

```typescript
// src/main.ts

import { Client, GatewayIntentBits, Events } from 'discord.js';
import { initializeATAC } from './bootstrap';
import { SlashCommandHandler } from './events/SlashCommandHandler';
import { MessageMentionHandler } from './events/MessageMentionHandler';

async function main() {
  // ATAC ã®åˆæœŸåŒ–
  const orchestrator = await initializeATAC();

  // Discord Client ã®åˆæœŸåŒ–
  const client = new Client({
    intents: [
      GatewayIntentBits.Guilds,
      GatewayIntentBits.GuildMessages,
      GatewayIntentBits.DirectMessages,
      GatewayIntentBits.MessageContent,
    ],
  });

  // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã®ç™»éŒ²
  const slashHandler = new SlashCommandHandler(orchestrator);
  const mentionHandler = new MessageMentionHandler(orchestrator);

  // Slash Command ã‚¤ãƒ™ãƒ³ãƒˆ
  client.on(Events.InteractionCreate, async interaction => {
    if (interaction.isChatInputCommand()) {
      await slashHandler.handle(interaction);
    }
  });

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¤ãƒ™ãƒ³ãƒˆ
  client.on(Events.MessageCreate, async message => {
    if (message.mentions.has(client.user!.id) || message.mentions.everyone) {
      await mentionHandler.handle(message);
    }
  });

  client.once(Events.ClientReady, () => {
    console.log(`âœ… Bot logged in as ${client.user?.tag}`);
  });

  await client.login(process.env.DISCORD_TOKEN);
}

main().catch(console.error);
```

---

## ã¾ã¨ã‚

ATAC ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ä¸»ãªåˆ©ç‚¹ï¼š

1. **ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£**ï¼šãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã§æ©Ÿèƒ½è¿½åŠ ãŒå®¹æ˜“
2. **ä¿å®ˆæ€§**ï¼šå„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒç‹¬ç«‹ã—ã€ãƒ†ã‚¹ãƒˆãƒ»æ”¹ä¿®ãŒåŠ¹ç‡çš„
3. **æŸ”è»Ÿæ€§**ï¼šé¡§å®¢ã”ã¨ã«ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½ã€è¤‡æ•°ã®ãƒˆãƒªã‚¬ãƒ¼æ–¹å¼ã«å¯¾å¿œ
4. **å†åˆ©ç”¨æ€§**ï¼šã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã§çµ±åˆã‚µãƒ¼ãƒ“ã‚¹ã‚’çµ±ä¸€çš„ã«ç®¡ç†
5. **ãƒãƒ«ãƒãƒ†ãƒŠãƒ³ãƒˆå¯¾å¿œ**ï¼šè¤‡æ•°é¡§å®¢ã«ç•°ãªã‚‹æ©Ÿèƒ½ã‚»ãƒƒãƒˆã‚’åŒæ™‚æä¾›

ã“ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ã‚ˆã‚Šã€ATAC ã¯ä¼æ¥­ã”ã¨ã®ç•°ãªã‚‹ãƒ‹ãƒ¼ã‚ºã«å¿œãˆã€ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«ã§ä¿å®ˆã—ã‚„ã™ã„ Discord Bot ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã¨ãªã‚Šã¾ã™ã€‚
